# 协商缓存中的 ETag 和 Last-Modified 机制

## 主要涉及的请求与响应头

- **ETag / If-None-Match**
- **Last-Modified / If-Modified-Since**

---

## ETag 和 If-None-Match

- **ETag** 是资源的唯一校验码，资源内容变化时 ETag 会变化。
- 浏览器请求时会带上 `If-None-Match`，服务器比对该值判断资源是否变化。
- 如果资源未变化，服务器返回 `304 Not Modified`，并在响应头中带上 ETag。
- 即使 ETag 未变，服务器每次响应都会带上这个 ETag。

### 缺点

1. **生成和校验开销**  
   - 生成 ETag 需要计算资源的哈希值或基于修改时间，可能带来 CPU 开销。  
   - 高并发时计算开销显著。

---

## Last-Modified 和 If-Modified-Since

- 服务器首次响应资源时，返回 `Last-Modified` 头，表示资源的最后修改时间。  
  例如：`Last-Modified: Thu, 31 Dec 2037 23:59:59 GMT`  
- 浏览器下次请求带上 `If-Modified-Since`，值为上次返回的 `Last-Modified`。  
- 服务器根据修改时间判断资源是否更新，未更新返回 `304 Not Modified`。

### 缺点

1. **时间精度限制**  
   - `Last-Modified` 以秒为单位，不能区分同秒多次修改。  
2. **动态内容问题**  
   - 动态生成内容更新时间变化，但实际内容未变，导致缓存失效。  
3. **客户端和服务器时间同步问题**  
   - 时钟偏差可能导致误判缓存状态。  
4. **首次加载无加速**  
   - 初次请求仍需下载完整资源。  
5. **内容未变但生成时间变**  
   - 例如带时间戳的动态页面。  
6. **不支持部分更新**  
   - 不能像 ETag 精细地支持部分变更。

### 适用场景

- 适合简单静态资源，结合 ETag 可以达到更精确控制。

---

## Koa 示例代码：使用 Last-Modified 协商缓存

```js
const fs = require('fs');
const Router = require('koa-router');
const router = new Router();

router.get('/pp', async (ctx) => {
    const ifModifiedSince = ctx.request.header['if-modified-since'];

    // 读取文件状态信息，获取修改时间
    const resourceStats = await new Promise((resolve, reject) => {
        fs.stat("./fs/a.txt", (err, stats) => {
            if (err) {
                reject(err);
            } else {
                resolve(stats);
            }
        });
    });

    const lastModified = resourceStats.mtime.toGMTString();

    // 判断请求头的时间和文件最后修改时间是否一致
    if (ifModifiedSince === lastModified) {
        ctx.status = 304; // 资源未修改，返回 304
        return;
    }

    // 设置响应头 Last-Modified
    ctx.set('Last-Modified', lastModified);

    // 读取文件内容
    const fileContent = await new Promise((resolve, reject) => {
        fs.readFile("./fs/a.txt", (err, data) => {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });

    ctx.body = fileContent;
});
